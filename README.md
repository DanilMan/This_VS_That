# This_VS_That

This website would be used to bring some ludicrous significance and joy to an RNG generator by making it into an event, along with a community to share results with. A user could input multiple random items of their choosing and then these items would be randomly selected to decide the question of this or that?

When I first started working on this project I drew out my databases and gave them some good thought as to how I wanted to arrange the information through the tables. After I made my decision, I started working on the index page by getting the values that I was manually typing into the data tables to be listed on the page. Once that was done, I began working on the input block for the user to input their items. This was all done through a combination of both vue.js and AJAX communicating with one another. The submit function (for user_brawl input) is by far one of the longest functions I wrote, and is somewhat spaghetti code. It does all of the necessary checks, first to make sure an instance of the same table item doesn’t already exist and then it chooses how the input is handled and increments and decrements values across tables. For example, if the user_brawl already existed, then it wouldn’t make a new one, but update its fields and then the related brawl’s and item’s fields that also need to be updated. It’s a bulky function, but it works. Using Vue.js I was able to easily get the results to replace the input elements and be displayed in the bulma banner.

After completing this, I worked on the search bar. The issue I had to figure out was how to make dynamic queries that could change depending on the amount of arguments being passed through the search bar. I found that I could concatenate queries together similar to how you would with strings. I did this in loops, moving my way up through the data tables. The reason I made a separate item_name table was so there would be no repeat names since users could create multiple items and they could all have the same name. So, I start at the bottom, searching the item_name table, if any of the search inputs match with any of its items. Then I check to see how many items have matching item_name ids. Then I get the brawl id from the items, get the subsequent brawls in a list, and return it. Now I mentioned this in the video, but I never got it working quite how I wanted it to. I wanted to somehow get the query to prioritize the search results that were more similar to the search input, but I wasn’t sure how to go about doing it. Most of my queries for the search bar were ‘or’ based, and I knew if I made them all ‘and’ based that the search would only return brawls which were exactly the same as the search input. I wanted a happy medium between the two. One idea I had was to get all the brawls that matched in a list, and then do some more sorting afterwards. I just didn’t like how inefficient it sounded. I wanted to use the py4web database query correctly. I looked into it further, and found that along with sorting the query selection, which I use a good amount in my project, you could also group and then sort the grouped selections, but I was a bit confused by how it worked. I also didn’t feel like I had the time to ponder over this.

After that, I moved onto working on the user page, which I had already finished the code that I needed to make it work. The submit function I used on the index page was implemented to also be used on the user page, and work exactly the same. It would create or update a user_brawl, but in the user_page. The returned result would be added to a vue.js array so the updated value could be displayed as a bulma element. On top of this I added a few other buttons. One is a rematch button that will take the user_brawl and re-shuffle it’s array and post the new data to the subsequent tables. The other is a delete button so users can delete their user_brawls. Also users could change the public or private state of their user_brawl with a toggle button.

I then worked on implementing the buttons for the displayed brawls on the index page. The first was a button to copy the brawl items into the start a brawl input so the player didn’t have to type them out if they liked a brawl they saw (this is where I also needed to use the vue key attribute, as I mentioned in the video). Then I worked on implementing the upvotes and downvotes. I decided to use the upvote system that reddit uses where the upvote and downvote share a single integer variable. I preferred this because I believe it looks better and makes it feel more like every like or dislike counts that much more. It toggles back and forth, on or off exactly like the upvote system from assignment 5. Of course this button, like all the other buttons I implemented, are signed and any changes on vue.js are posted on the data tables. For example, with the upvote system, on vue.js I use 3 variables to cache the information locally. One for the int that holds the sum of all up and down votes. Then I had 2 booleans, one for up and one for down. On the press of either up or down button I would update these values and then post the increments/decrements to the database. I also worked on the comments. Which I wanted to have them update every time they were dropped down. This works by getting the data from the comment table everytime the drop down button is clicked down. Also I made it so if there aren’t any comments in the first place, then the drop down button doesn’t appear. The comment button itself is very similar to the comment button/setup from the assignment 5. On pressing it opens up a text box and you can type, post, or cancel. I also made it very similar, in that the comments have a delete button and they also have an upvote and downvote button. I ran into an issue here, that I mentioned in the video. When the comment upvote buttons were pressed, the values on the database were updating, but the vue.js variable, I was using to keep track of the sum of all up and down votes, wasn’t changing. I realized that I had a reactivity issue, which I had dealt with earlier with the initial inputs. This one, I’m pretty sure was occurring because I was trying to get a vue object stored within another vue object to stay reactive. I assume for better optimization, vue.js doesn’t keep track of some items if not explicitly told to do so. So, I found a way and used the key attribute which explicitly tells vue to keep track of the variable and make it reactive.

Lastly I worked on page turning and loading for the search results, the user page, and the comments. In both page turning cases, if the displayed elements went beyond a specified amount I wanted to limit the amount of data being locally cached. I made a variable in vue to keep track of the page and then each time the page was clicked left or right the value would increment or decrement accordingly, and the results from the database were grabbed from a min and max of the query selection. I used the page variable to get the min and max in the selection. Multiplying by 10 for the min and multiplying by 10 and then adding by 11 for the max. The extra result was then used to check if there were any more results on the next page. I did something very similar for the load more for the brawl comments. But instead of changing the min I left it at zero, so when you click load more, it gets the first selection up until the max n selection.

I worked pretty hard to try and get my project deployed. I had followed the tutorial and was on the 5th video when I ran into too many issues and wasn’t sure what to do. I went on slack and saw people had asked the same questions I was going to ask. They got responses, but they weren’t enough to get mine working. I also hit other snags along the way, one of them being that I had written the user_brawl table to have a field that was a list of integers. I didn’t know at the time, but SQL doesn’t have support for such a data structure. So while working through the tutorials to get my app deployed I had to stop and change my table. It ended up not being as difficult as I had thought, but I was worried I was going to break my completed project by changing a core part of it. Instead of using a list of integers, I decided to split the Field into 2. One would hold the first item id (the winner) as an integer for quick access, and the other would hold the items’ placement order as a string of numbers separated by commas. Anyways, If you look you’ll see I went through the steps to deploy my app, and my app was completely ready for deployment. I just got overwhelmed and lost in the errors while trying to figure out how to make the linux/mac based commands work with my windows machine.

I know I learned a great amount working on this project. I had never made a website before, or even thought I would ever try. I of course really wish I could have deployed it, so I could share it with friends. I think I accomplished more than what I thought I would, looking back at my expectations at the beginning of the class. Though, I wish I had the time to have added the phaser framework bot fighting simulation. I hope once I get enough of a mental break from code this summer I’ll continue to work on this project.
